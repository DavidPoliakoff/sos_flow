#include "worker.h"
#include "stdio.h"
#include "stdlib.h"
#include "adios.h"

/* 
 * Worker A is the first application in the workflow.
 * It does some "computation" and communication for N
 * iterations, and it produces "output" that is "input" to worker_b.
 */

int iterations = 1;

void validate_input(int argc, char* argv[]) {
    if (argc < 2) {
        my_printf("Usage: %s <num iterations>\n", argv[0]);
        exit(1);
    }
    if (commsize < 2) {
        my_printf("%s requires at least 2 processes.\n", argv[0]);
        exit(1);
    }
    iterations = atoi(argv[1]);
}

void do_neighbor_exchange(void) {
    int outdata[100] = {1};
    int indata[100] = {0};
    int thistag = 1;
    MPI_Status status;
    if (myrank % 2 == 0) {
        // send to left neighbor
        MPI_Send(outdata,              /* message buffer */
                 100,               /* one data item */
                 MPI_INT,           /* data item is an integer */
                 get_left_neighbor(),              /* destination process rank */
                 thistag,           /* user chosen message tag */
                 MPI_COMM_WORLD);   /* default communicator */
        int thistag = 2;
        // receive from right neighbor
        MPI_Recv(indata,            /* message buffer */
                 100,                 /* one data item */
                 MPI_INT,        /* of type double real */
                 get_right_neighbor(),    /* receive from any sender */
                 thistag,       /* any type of message */
                 MPI_COMM_WORLD,    /* default communicator */
                 &status);          /* info about the received message */
    } else {
        // receive from right neighbor
        MPI_Recv(indata,            /* message buffer */
                 100,                 /* one data item */
                 MPI_INT,        /* of type double real */
                 get_right_neighbor(),    /* receive from any sender */
                 thistag,       /* any type of message */
                 MPI_COMM_WORLD,    /* default communicator */
                 &status);          /* info about the received message */
        int thistag = 2;
        // send to left neighbor
        MPI_Send(outdata,              /* message buffer */
                 100,               /* one data item */
                 MPI_INT,           /* data item is an integer */
                 get_left_neighbor(),              /* destination process rank */
                 thistag,           /* user chosen message tag */
                 MPI_COMM_WORLD);   /* default communicator */
    }

}

int worker(int argc, char* argv[]) {
    printf("%d of %d In worker A\n", myrank, commsize);

    /* validate input */
    validate_input(argc, argv);

    my_printf("Worker A will execute %d iterations.\n", iterations);

    /* ADIOS: These declarations are required to match the generated
     *        gread_/gwrite_ functions.  (And those functions are
     *        generated by calling 'gpp.py adios_config.xml') ...
     */
    int       adios_err;
    uint64_t  adios_groupsize;
    uint64_t  adios_totalsize;
    uint64_t  adios_handle;
    char      adios_filename[256];
    MPI_Comm  adios_comm;

    /* ADIOS: Can duplicate, split the world, whatever.
     *        This allows you to have P writers to N files.
     *        With no splits, everyone shares 1 file, but
     *        can write lock-free by using different areas.
     */
    MPI_Comm_dup(MPI_COMM_WORLD, &adios_comm);

    /* ADIOS: This variable holds the value to output, as specified in
     *        the adios_config.xml file.
     */
    double   *sample_val;

    sample_val = (double *) malloc( iterations * sizeof(double) );

    /* ADIOS: Set up the adios communications and buffers, open the file.
     */
    sprintf(adios_filename, "sample_data.bp");
    adios_init("adios_config.xml", adios_comm);
    adios_open(&adios_handle, "sample_data", adios_filename, "w", adios_comm);


    int i;
    for (i = 0 ; i < iterations ; i++ ) {
        /* Do some exchanges with neighbors */
        do_neighbor_exchange();
        /* "Compute" */
        compute(i);
        /* Write output */
        my_printf(".");

        /* ADIOS: Set the value we wish to output into 'sample_var':
         */
        sample_val[i] = (double) i / 2;

        /* ADIOS: Actually write the data out.
         *        Yes, this is the recommended method, and this way, changes in
         *        configuration with the .XML file will, even in the worst-case
         *        scenario, merely require running 'gpp.py adios_config.xml'
         *        and typing 'make'.
         */
        #include "gwrite_sample_data.ch"

    }

    /* ADIOS: Close out the file completely and finalize.
     *        If MPI is being used, this must happen before MPI_Finalize().
     */
    adios_close(adios_handle);
    adios_finalize(myrank);

    free(sample_val);

    /* exit */
    return 0;
}
